\section{Filters}

\subsection{Introduction}

\subsubsection{Key Concepts}

glscopeclient and libscopehal are based on a ``filter graph" architecture internally. The filter graph is a directed
acyclic graph with a set of source nodes (waveforms captured from hardware or loaded from a file) and sink nodes
(waveform views) connected by edges representing data flow.

A protocol decode is simply an intermediate node in the graph, which takes input from one or more waveform nodes and
outputs a waveform which may be displayed in a waveform view, used as input to other protocol decodes, or both. A
waveform is a series of data points which may represent voltages, digital samples, or arbitrarily complex protocol data
structures.

As a result, there is no internal distinction between math functions and protocol decodes, and it is possible to chain
them arbitrarily. Consider the following example\footnote{Not all of these filters are currently implemented}.

\begin{itemize}
\item Two analog waveforms representing serial data and clock are acquired
\item Each analog waveform is thresholded, producing a digital waveform
\item The two digital waveforms are decoded as $I^2C$, producing a series of packets
\item The $I^2C$ packets are decoded as writes to a serial DAC, producing an analog waveform
\item A moving average filter is applied to the analog waveform
\end{itemize}

In this document we use the term ``protocol decoder" consistently to avoid ambiguity.

\subsubsection{Conventions}

Each protocol decode takes one or more inputs (vector inputs), zero or more parameters (scalar inputs), and outputs a
signal (vector output).

If the output signal is a complex-valued type (as opposed to a single scalar, e.g. voltage, at each sample) the
``Output Signal" section will include a table describing how various types of output data are displayed. Printf-style
format codes maybe used for clarity. For example, ``\%02x" means data is formatted as hexadecimal bytes with leading
zeroes.

All protocol decodes with complex output use a standardized set of colors to display various types of data fields in a
consistent manner. These colors are currently hard coded in a table but will be made editable in the future
(scopehal-apps:43)

Suggestions on changes to the default colors, or new categories for color coding, are welcome

\begin{tabularx}{16cm}{llX}
\thickhline
\textbf{Color name} & \textbf{Use case} & \textbf{Default Color} \\
\thickhline
Address & Memory addresses & \cellcolor{address}\textcolor{black}{\#ffff00} \\
\thickhline
Checksum Bad & Incorrect CRC/checksum & \cellcolor{checksumbad}\textcolor{white}{\#ff0000} \\
\thickhline
Checksum OK & Valid CRC/checksum & \cellcolor{checksumok}\textcolor{black}{\#00ff00} \\
\thickhline
Control & Miscellaneous control data & \cellcolor{control}\textcolor{white}{\#c000a0} \\
\thickhline
Data & User data & \cellcolor{data}\textcolor{white}{\#336699} \\
\thickhline
Error & Malformed/unreadable data & \cellcolor{error}\textcolor{white}{\#ff0000} \\
\thickhline
Idle & Inter-frame gaps & \cellcolor{idle}\textcolor{white}{\#404040} \\
\thickhline
Preamble & Preamble/sync words & \cellcolor{preamble}\textcolor{white}{\#808080} \\
\thickhline
\end{tabularx}

\subsection{8B/10B (IBM)}

\subsection{8B/10B (TMDS)}

Decodes the 8-to-10 Transition Minimized Differential Signalling line code used in DVI and HDMI.

\subsubsection{Inputs}

\begin{tabularx}{16cm}{llX}
\thickhline
\textbf{Signal name} & \textbf{Type} & \textbf{Description} \\
\thickhline
data & 1-bit digital & Serial TMDS data line \\
\thickhline
clk & 1-bit digital & DDR \emph{bit} clock, typically generated by use of the \hyperref[filter:cdrpll]{Clock Recovery
(PLL)} decode on the input data. Note that this is 5x the rate of the HDMI pixel clock signal. \\
\thickhline
\end{tabularx}

\subsubsection{Parameters}

This decode takes no parameters.

\subsubsection{Output Signal}

The TMDS decode outputs a time series of TMDS sample objects. These consist of a type field and a byte of data.

The output of the TMDS decode is commonly fed to the \hyperref[filter:dvi]{DVI} or \hyperref[filter:hdmi]{HDMI}
protocol decoders.

\begin{tabularx}{16cm}{lllX}
\thickhline
\textbf{Type} & \textbf{Description} & \textbf{Color} & \textbf{Format} \\
\thickhline
Control & Control codes (H/V sync) & \cellcolor{control}\textcolor{white}{Control} & CTL\%d \\
\thickhline
Data & Pixel/island data & \cellcolor{data}\textcolor{white}{Data} & \%02x \\
\thickhline
Error & Malformed data & \cellcolor{error}\textcolor{white}{Error} & ERROR \\
\thickhline
Guard band & HDMI data/video guard band & \cellcolor{preamble}\textcolor{white}{Preamble} & GB \\
\thickhline
\end{tabularx}

\subsection{AC Couple}
\subsection{Average}
\subsection{Base}
\subsection{CAN}
\subsection{Clock Jitter (TIE)}
\subsection{Clock Recovery (PLL)}
\label{filter:cdrpll}

\subsection{Clock Recovery Debug}
\subsection{Clock Recovery (UART)}
\subsection{DC Offset}
\subsection{Difference}
\subsection{DVI}
\label{filter:dvi}

\subsection{Ethernet - 10baseT}
\subsection{Ethernet - 100baseTX}
\subsection{Ethernet Autonegotiation}
\subsection{Eye Bitrate}
\subsection{Eye Height}
\subsection{Eye Pattern}
\subsection{Eye Period}
\subsection{Eye P-P Jitter}
\subsection{Eye Width}
\subsection{Fall 80-20}
\subsection{Fall 90-10}
\subsection{Frequency}
\subsection{FFT}
\subsection{HDMI}
\label{filter:hdmi}
\subsection{$I^2C$}
\subsection{JTAG}
\subsection{Max}
\subsection{MDIO}
\subsection{Min}
\subsection{Moving Average}
\subsection{Overshoot}
\subsection{Parallel Bus}
\subsection{Period}
\subsection{Peak-Peak}
\subsection{Rise 10-90}
\subsection{Fall 20-80}
\subsection{Sin(x)/x Interpolation}
\subsection{Threshold}
\subsection{Top}
\subsection{UART}
\subsection{Undershoot}
\subsection{USB 1.0 / 2.x Activity}
\subsection{USB 1.0 / 2.x Packet}
\subsection{USB 1.0 / 2.x PCS}
\subsection{USB 1.0 / 2.x PMA}
\subsection{Waterfall}
